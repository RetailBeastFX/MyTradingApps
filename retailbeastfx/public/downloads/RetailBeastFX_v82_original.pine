// This Pine Scriptâ„¢ code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/
// Â© RetailBeast 2025

//@version=5
indicator("RetailBeastFX Premium [v8.4 Beast Mode]", shorttitle="RBFX v8.4", overlay=true, max_bars_back=500, max_lines_count=500, max_boxes_count=500, max_labels_count=500, dynamic_requests=true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸš€ QUICK START â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string modeGroup = "ğŸš€ Quick Start"

string presetTooltip = "ğŸ”¥ BEAST MODE: High-prob killzone setups only (Gold/USDJPY/NAS100)\nğŸ“ˆ SWING: 24/7 with HTF bias\nâœ¨ CLEAN: Minimal visuals\nâš™ï¸ CUSTOM: Your settings"
string preset = input.string("ğŸ”¥ Beast Mode", "Preset", options=["ğŸ”¥ Beast Mode", "ğŸ“ˆ Swing Trader", "âœ¨ Clean Chart", "âš™ï¸ Custom"], group=modeGroup, tooltip=presetTooltip)

string modeTooltip = "SCALPER: London/NY killzones only (best for beginners)\nDAY TRADER: Extended hours\nSWING: 24/7 with EMA 200 filter"
string gameMode = input.string("SCALPER", "Trading Mode", options=["SCALPER", "DAY TRADER", "SWING"], group=modeGroup, tooltip=modeTooltip)

string alphaTooltip = "Choose your strategy style:\nâ€¢ Off: Classic BB signals only\nâ€¢ Trend Following: Ride the 200 SMA\nâ€¢ Mean Reversion: Fade RSI extremes\nâ€¢ Swing Pullbacks: Enter at EMA50\nâ€¢ Breakout: Catch BB squeezes\nâ€¢ All: Full confluence mode"
string alphaStrategy = input.string("Off", "Strategy Style", options=["Off", "Trend Following", "Mean Reversion", "Swing Pullbacks", "Breakout", "All Signals"], group=modeGroup, tooltip=alphaTooltip)

bool showSignals = input.bool(true, "Show Buy/Sell Arrows", group=modeGroup, tooltip="Display entry signals on chart")
bool killzoneSignalsOnly = input.bool(true, "Killzone Filter", group=modeGroup, tooltip="Only show signals during London/NY sessions (recommended)")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸ“Š SIGNALS & CORE â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string coreGroup = "ğŸ“Š Signals & Core"
bool showBB = input.bool(true, "Show Bollinger Bands", group=coreGroup)
int bbLengthInput = input.int(20, "BB Length", minval=5, maxval=50, group=coreGroup, inline="bb")
float bbMult = input.float(2.0, "BB Deviation", minval=0.5, maxval=3.0, step=0.1, group=coreGroup, inline="bb")
bool autoAdapt = input.bool(true, "Auto-Adapt to Timeframe", group=coreGroup, tooltip="Automatically adjust BB/EMA periods based on chart timeframe")

bool showEMAs = input.bool(true, "Show EMAs", group=coreGroup)
int emaFastInput = input.int(8, "Fast EMA", minval=3, maxval=50, group=coreGroup, inline="ema1")
int emaSlowInput = input.int(21, "Slow EMA", minval=10, maxval=100, group=coreGroup, inline="ema1")
int emaTrend = input.int(200, "Trend EMA", minval=50, maxval=500, group=coreGroup, tooltip="200 EMA for swing mode bias")
int emaTrail = input.int(5, "Trail EMA", minval=3, maxval=20, group=coreGroup, tooltip="Visual trailing stop guide")
bool showEMARibbon = input.bool(true, "Show EMA Ribbon", group=coreGroup, tooltip="Fill between Fast & Slow EMA")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ â° SESSIONS & TIMING â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string kzGroup = "â° Sessions & Timing"
bool showKillzones = input.bool(true, "Show Session Boxes", group=kzGroup, tooltip="Highlight trade windows on chart")
bool showGradientKZ = input.bool(true, "Gradient Fill", group=kzGroup, tooltip="Apply gradient background to killzones")
bool showPowerHour = input.bool(true, "Show Power Hour", group=kzGroup, tooltip="London/NY overlap - highest volatility")

string londonStart = input.session("0300-0600", "London (EST)", group=kzGroup, inline="london")
color londonColor = input.color(color.new(#00CED1, 85), "", group=kzGroup, inline="london")

string nyStart = input.session("0800-1100", "New York (EST)", group=kzGroup, inline="ny")
color nyColor = input.color(color.new(#FF8C00, 85), "", group=kzGroup, inline="ny")

string extendedStart = input.session("0200-1200", "Extended Hours", group=kzGroup, inline="ext")
color extendedColor = input.color(color.new(#9370DB, 90), "", group=kzGroup, inline="ext")
color powerHourColor = input.color(color.new(#1E90FF, 75), "Power Hour", group=kzGroup)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸ”² SMC & ICT TOOLS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string smcGroup = "ğŸ”² SMC & ICT Tools"
bool showOB = input.bool(true, "Order Blocks", group=smcGroup, tooltip="Institutional order zones")
bool showSwings = input.bool(true, "Swing Points", group=smcGroup)
int maxOBCount = input.int(2, "Max OBs", minval=1, maxval=10, group=smcGroup)
bool deleteOBOnMitigation = input.bool(true, "Auto-Remove Mitigated", group=smcGroup, tooltip="Delete OB when price fills it")
int pivotLen = input.int(5, "Pivot Sensitivity", minval=2, maxval=20, group=smcGroup)
int obMinConsecutive = input.int(2, "OB Min Consecutive", minval=1, maxval=5, group=smcGroup, tooltip="Min consecutive same-direction candles for valid OB (ICT quality filter)")

bool showFVG = input.bool(false, "Fair Value Gaps", group=smcGroup, tooltip="Imbalance zones (toggle ON)")
bool showIFVG = input.bool(false, "Show iFVG", group=smcGroup, tooltip="Inverse FVG when gap is filled")
bool deleteFVGOnMitigation = input.bool(true, "Auto-Remove Filled FVGs", group=smcGroup)
int maxFVGCount = input.int(3, "Max FVGs", minval=1, maxval=10, group=smcGroup)

bool showSB = input.bool(true, "Suspension Blocks", group=smcGroup, tooltip="ICT 2025: Dual-imbalance pause zones")
int sbLookback = input.int(50, "SB Lookback", minval=10, maxval=200, group=smcGroup)
float sbMinGapATR = input.float(0.1, "SB Min Gap (ATR x)", minval=0.05, maxval=0.5, step=0.05, group=smcGroup)
int maxSBCount = input.int(3, "Max SBs", minval=1, maxval=10, group=smcGroup)

bool showVI = input.bool(false, "Volume Imbalance", group=smcGroup, tooltip="2-candle wick gaps")
int maxVICount = input.int(3, "Max VIs", minval=1, maxval=10, group=smcGroup)

bool show1stFVG = input.bool(true, "1st Presented FVG", group=smcGroup, tooltip="ICT 2025: First FVG after 9:30 AM NY open - key daily reference")
color firstFVGColor = input.color(color.new(#FFD700, 70), "1st FVG Color", group=smcGroup)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸ“ KEY LEVELS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string levelsGroup = "ğŸ“ Key Levels"
bool showPDHL = input.bool(true, "Previous Day H/L", group=levelsGroup, tooltip="Major liquidity pools")
bool showWeeklyOpen = input.bool(true, "Weekly Open", group=levelsGroup)
bool showMidnightOpen = input.bool(true, "Midnight Open", group=levelsGroup, tooltip="ICT True Day reference (00:00 EST)")
bool showSessionOpens = input.bool(true, "Session Opens", group=levelsGroup, tooltip="London & NY opening prices")
bool showSilverBullet = input.bool(true, "Silver Bullet Zone", group=levelsGroup, tooltip="10-11 AM EST high probability window")
bool showLiqSweeps = input.bool(true, "Liquidity Sweeps", group=levelsGroup, tooltip="Detect stop hunts")
bool extendLevelLines = input.bool(false, "Extend Lines Right", group=levelsGroup)
bool showTS = input.bool(false, "Turtle Soup", group=levelsGroup, tooltip="False breakout pattern (ICT)")
int tsLookback = input.int(20, "TS Lookback", minval=5, maxval=50, group=levelsGroup)
bool tsSessionFilter = input.bool(true, "TS Session Filter", group=levelsGroup)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸ›¡ï¸ RISK MANAGEMENT â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string riskGroup = "ğŸ›¡ï¸ Risk Management"
bool showATRLevels = input.bool(true, "Show SL/TP Lines", group=riskGroup, tooltip="Auto-draw SL/TP from signals")
int atrLength = input.int(14, "ATR Length", minval=5, maxval=50, group=riskGroup)
float atrMultSL = input.float(1.5, "SL Distance (ATR x)", minval=0.5, maxval=5.0, step=0.1, group=riskGroup)
float atrMultTP = input.float(3.0, "TP Distance (ATR x)", minval=1.0, maxval=10.0, step=0.5, group=riskGroup)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸ”¬ ADVANCED â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string advGroup = "ğŸ”¬ Advanced"
string displayMode = input.string("Present", "Display Mode", options=["Present", "Historical"], group=advGroup, tooltip="Present=Recent only, Historical=Full history")
int presentLookback = input.int(50, "Present Mode Bars", minval=10, maxval=500, group=advGroup)

bool showHTFLevels = input.bool(true, "HTF Confluence", group=advGroup, tooltip="Show higher timeframe OBs/FVGs")
string htfTimeframe = input.timeframe("60", "HTF Timeframe", group=advGroup, tooltip="60=1H, 240=4H, D=Daily")
bool showHTFOrderBlocks = input.bool(true, "HTF Order Blocks", group=advGroup)
bool showHTFFVG = input.bool(true, "HTF Fair Value Gaps", group=advGroup)
int maxHTFOB = input.int(2, "Max HTF OBs", minval=1, maxval=5, group=advGroup)
int maxHTFFVG = input.int(2, "Max HTF FVGs", minval=1, maxval=5, group=advGroup)
bool fractalFilter = input.bool(true, "Fractal Filter", group=advGroup, tooltip="Only signals near HTF levels - cuts fakeouts")
float fractalATRMult = input.float(1.0, "Fractal Proximity (ATR x)", minval=0.5, maxval=3.0, step=0.5, group=advGroup)

int alphaRSIPeriod = input.int(2, "RSI Period", minval=1, maxval=14, group=advGroup, tooltip="For Mean Reversion strategy")
int alphaRSIOversold = input.int(15, "RSI Oversold", minval=5, maxval=30, group=advGroup)
int alphaRSIOverbought = input.int(85, "RSI Overbought", minval=70, maxval=95, group=advGroup)
bool showAlphaLabels = input.bool(true, "Show Strategy Labels", group=advGroup)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ğŸ¨ APPEARANCE â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
string visGroup = "ğŸ¨ Appearance"
bool showDashboard = input.bool(true, "Show Dashboard", group=visGroup)
bool showCandleColors = input.bool(true, "Custom Candles", group=visGroup, tooltip="Gray=Neutral, Green/Red=Trend")
bool showHTFBackground = input.bool(true, "HTF Trend Background", group=visGroup, tooltip="Tint based on 1H trend")

color signalBuyColor = input.color(#00FF7F, "Buy Arrow", group=visGroup, inline="sig")
color signalSellColor = input.color(#FF4757, "Sell Arrow", group=visGroup, inline="sig")
color bbColor = input.color(color.new(#64B5F6, 50), "BB Color", group=visGroup)
color emaBullColor = input.color(color.new(#00E676, 70), "Bull Ribbon", group=visGroup, inline="ribcol")
color emaBearColor = input.color(color.new(#FF5252, 70), "Bear Ribbon", group=visGroup, inline="ribcol")
color bullOBColor = input.color(color.new(#26A69A, 85), "Bull OB", group=visGroup, inline="obcol")
color bearOBColor = input.color(color.new(#EF5350, 85), "Bear OB", group=visGroup, inline="obcol")
color bullFVGColor = input.color(color.new(#00E676, 80), "Bull FVG", group=visGroup, inline="fvgcol")
color bearFVGColor = input.color(color.new(#FF5252, 80), "Bear FVG", group=visGroup, inline="fvgcol")
color sbColor = input.color(color.new(#FFB400, 70), "Suspension Block", group=visGroup)
color bullVIColor = input.color(color.new(#00BCD4, 80), "Bull VI", group=visGroup, inline="vicol")
color bearVIColor = input.color(color.new(#E91E63, 80), "Bear VI", group=visGroup, inline="vicol")
color pdhColor = input.color(color.new(#00E676, 30), "PDH", group=visGroup, inline="pdhl")
color pdlColor = input.color(color.new(#FF5252, 30), "PDL", group=visGroup, inline="pdhl")
color weeklyOpenColor = input.color(color.new(#FFD700, 50), "Weekly Open", group=visGroup)
color midnightColor = input.color(color.new(#9C27B0, 40), "Midnight Open", group=visGroup)
color londonOpenColor = input.color(color.new(#00BCD4, 50), "London Open", group=visGroup, inline="sessopen")
color nyOpenColor = input.color(color.new(#FF9800, 50), "NY Open", group=visGroup, inline="sessopen")
color silverBulletColor = input.color(color.new(#00FFFF, 80), "Silver Bullet", group=visGroup)
color tsBullColor = input.color(color.new(#00E676, 40), "Bull TS", group=visGroup, inline="tscol")
color tsBearColor = input.color(color.new(#FF5252, 40), "Bear TS", group=visGroup, inline="tscol")
color htfOBBullColor = input.color(color.new(#00E676, 90), "HTF Bull OB", group=visGroup, inline="htfob")
color htfOBBearColor = input.color(color.new(#FF5252, 90), "HTF Bear OB", group=visGroup, inline="htfob")
color htfFVGBullColor = input.color(color.new(#4CAF50, 92), "HTF Bull FVG", group=visGroup, inline="htffvg")
color htfFVGBearColor = input.color(color.new(#F44336, 92), "HTF Bear FVG", group=visGroup, inline="htffvg")
color slColor = input.color(color.new(#FF5252, 50), "SL Line", group=visGroup, inline="sltp")
color tpColor = input.color(color.new(#00E676, 50), "TP Line", group=visGroup, inline="sltp")
color ifvgColor = input.color(color.new(#FFD700, 75), "iFVG", group=visGroup)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ TIMEFRAME DETECTION & CALCULATIONS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â”€â”€â”€ TIMEFRAME DETECTION â”€â”€â”€
bool isTF_1m = timeframe.period == "1" or timeframe.period == "2" or timeframe.period == "3"
bool isTF_5m = timeframe.period == "5"
bool isTF_15m = timeframe.period == "15"
bool isTF_1h = timeframe.period == "60"
bool isTF_4h = timeframe.period == "240"
bool isTF_D = timeframe.period == "D" or timeframe.period == "1D"
bool isTF_scalp = isTF_1m or isTF_5m
bool isTF_day = isTF_15m or isTF_1h
bool isTF_swing = isTF_4h or isTF_D

// â”€â”€â”€ ADAPTIVE BB LENGTH â”€â”€â”€
// Higher TF = longer BB period for smoother bands
int bbLength = autoAdapt ? (isTF_1m ? 14 : isTF_5m ? 18 : isTF_15m ? 20 : isTF_1h ? 20 : isTF_4h ? 25 : isTF_D ? 30 : bbLengthInput) : bbLengthInput

// Calculate Bollinger Bands (with adaptive length)
float bbBasis = ta.sma(close, bbLength)
float bbDev = bbMult * ta.stdev(close, bbLength)
float bbUpper = bbBasis + bbDev
float bbLower = bbBasis - bbDev

// â”€â”€â”€ ADAPTIVE EMA PERIODS â”€â”€â”€
// Higher TF = longer EMA periods
int emaFast = autoAdapt ? (isTF_1m ? 5 : isTF_5m ? 8 : isTF_15m ? 9 : isTF_1h ? 12 : isTF_4h ? 15 : isTF_D ? 20 : emaFastInput) : emaFastInput
int emaSlow = autoAdapt ? (isTF_1m ? 13 : isTF_5m ? 21 : isTF_15m ? 26 : isTF_1h ? 26 : isTF_4h ? 50 : isTF_D ? 50 : emaSlowInput) : emaSlowInput

// Calculate EMAs (with adaptive periods)
float ema8 = ta.ema(close, emaFast)
float ema21 = ta.ema(close, emaSlow)
float ema200 = ta.ema(close, emaTrend)
float ema50 = ta.ema(close, 50)  // For Alpha Edge Swing Pullbacks
float ema5 = ta.ema(close, emaTrail)

// BB Squeeze for Alpha Edge Breakout strategy
float bbWidthPct = (bbUpper - bbLower) / bbBasis
bool bbSqueezeActive = bbWidthPct < ta.sma(bbWidthPct, 20)

// Alpha Edge RSI for Mean Reversion
float alphaRSI = ta.rsi(close, alphaRSIPeriod)
bool alphaRSIOversoldActive = alphaRSI < alphaRSIOversold
bool alphaRSIOverboughtActive = alphaRSI > alphaRSIOverbought

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ TIMEZONE FUNCTIONS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
tz = "America/New_York"

// Session detection functions
isInSession(string sess) =>
    not na(time(timeframe.period, sess, tz))

bool inLondon = isInSession("0300-0600")
bool inNY = isInSession("0800-1100")
bool inExtended = isInSession("0200-1200")
bool inPowerHour = isInSession("0930-1030")  // NYSE Open - highest volume hour

// Check if we're in a valid trading session based on mode
isValidSession() =>
    switch gameMode
        "SCALPER" => inLondon or inNY
        "DAY TRADER" => inExtended
        "SWING" => true
        => true

bool validSession = isValidSession()

// â”€â”€â”€ DISPLAY MODE FILTER (User-adjustable) â”€â”€â”€
// Uses presentLookback input - adjust based on your timeframe and preference
int barsLookback = displayMode == "Present" ? presentLookback : 50000
bool showOnChart = bar_index >= (last_bar_index - barsLookback)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ SIGNAL LOGIC (ANTI-REPAINT) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Trend conditions
bool bullTrend = ema8 > ema21
bool bearTrend = ema8 < ema21
bool aboveSMA200 = close > ema200
bool belowSMA200 = close < ema200

// Swing mode filter
bool swingBullOK = gameMode != "SWING" or aboveSMA200
bool swingBearOK = gameMode != "SWING" or belowSMA200

// BB touch detection (confirmed bar only)
bool touchedLowerBB = low <= bbLower
bool touchedUpperBB = high >= bbUpper

// Candle direction
bool bullCandle = close > open
bool bearCandle = close < open

// â”€â”€â”€ ALPHA EDGE A+ SIGNALS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. TREND FOLLOWING: Cross above/below 200 SMA
bool alphaTrendBuy = ta.crossover(close, ema200)
bool alphaTrendSell = ta.crossunder(close, ema200)

// 2. MEAN REVERSION: RSI extremes WITH trend filter
bool alphaMeanRevBuy = alphaRSIOversoldActive and aboveSMA200 and not alphaRSIOversoldActive[1]
bool alphaMeanRevSell = alphaRSIOverboughtActive and belowSMA200 and not alphaRSIOverboughtActive[1]

// 3. SWING PULLBACKS: Touch EMA50 zone in established trend
bool pullbackZone = low <= ema50 and high >= ema50
bool alphaPullbackBuy = aboveSMA200 and bullTrend and pullbackZone and close > ema8
bool alphaPullbackSell = belowSMA200 and bearTrend and pullbackZone and close < ema8
bool alphaPullbackBuySignal = alphaPullbackBuy and not alphaPullbackBuy[1]
bool alphaPullbackSellSignal = alphaPullbackSell and not alphaPullbackSell[1]

// 4. BREAKOUT: Squeeze â†’ Expansion
bool alphaBreakoutBuy = bbSqueezeActive[1] and close > bbUpper and ta.crossover(close, bbUpper)
bool alphaBreakoutSell = bbSqueezeActive[1] and close < bbLower and ta.crossunder(close, bbLower)

// â”€â”€â”€ ORIGINAL BB-BASED SIGNALS â”€â”€â”€
bool originalBuy = bullCandle and touchedLowerBB and bullTrend and swingBullOK and validSession
bool originalSell = bearCandle and touchedUpperBB and bearTrend and swingBearOK and validSession

// â”€â”€â”€ ALPHA EDGE SIGNAL SELECTION â”€â”€â”€
bool alphaBuy = switch alphaStrategy
    "Trend Following" => alphaTrendBuy and validSession
    "Mean Reversion" => alphaMeanRevBuy and validSession
    "Swing Pullbacks" => alphaPullbackBuySignal and validSession
    "Breakout" => alphaBreakoutBuy and validSession
    "All Signals" => (alphaTrendBuy or alphaMeanRevBuy or alphaPullbackBuySignal or alphaBreakoutBuy) and validSession
    => false

bool alphaSell = switch alphaStrategy
    "Trend Following" => alphaTrendSell and validSession
    "Mean Reversion" => alphaMeanRevSell and validSession
    "Swing Pullbacks" => alphaPullbackSellSignal and validSession
    "Breakout" => alphaBreakoutSell and validSession
    "All Signals" => (alphaTrendSell or alphaMeanRevSell or alphaPullbackSellSignal or alphaBreakoutSell) and validSession
    => false

// â”€â”€â”€ FINAL SIGNAL: Alpha Edge if enabled, otherwise original â”€â”€â”€
bool rawBuySignal = alphaStrategy != "Off" ? alphaBuy : originalBuy
bool rawSellSignal = alphaStrategy != "Off" ? alphaSell : originalSell

// Anti-repaint: Signal only on confirmed bar
// Note: fractalFilter (HTF proximity) is applied in signal arrows section after HTF levels are calculated
bool buySignal = rawBuySignal and barstate.isconfirmed
bool sellSignal = rawSellSignal and barstate.isconfirmed

// Alpha Edge signal labels (when enabled)
if showAlphaLabels and buySignal and alphaStrategy != "Off" and showOnChart
    string alphaLabel = alphaStrategy == "Trend Following" ? "ğŸ“ˆ TREND" : alphaStrategy == "Mean Reversion" ? "ğŸ”„ MEAN REV" : alphaStrategy == "Swing Pullbacks" ? "ğŸ¯ PULLBACK" : alphaStrategy == "Breakout" ? "ğŸ’¥ BREAKOUT" : "âš¡ ALPHA"
    label.new(bar_index, low, alphaLabel, style=label.style_label_up, color=color.new(#00E676, 30), textcolor=color.white, size=size.tiny)

if showAlphaLabels and sellSignal and alphaStrategy != "Off" and showOnChart
    string alphaLabel = alphaStrategy == "Trend Following" ? "ğŸ“‰ TREND" : alphaStrategy == "Mean Reversion" ? "ğŸ”„ MEAN REV" : alphaStrategy == "Swing Pullbacks" ? "ğŸ¯ PULLBACK" : alphaStrategy == "Breakout" ? "ğŸ’¥ BREAKOUT" : "âš¡ ALPHA"
    label.new(bar_index, high, alphaLabel, style=label.style_label_down, color=color.new(#FF5252, 30), textcolor=color.white, size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ TFO-STYLE ICT KILLZONES + PIVOTS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Session tracking variables
var float londonHigh = na
var float londonLow = na
var int londonStartBar = na
var bool londonActive = false

var float nyHigh = na
var float nyLow = na
var int nyStartBar = na
var bool nyActive = false

var float asianHigh = na
var float asianLow = na
var int asianStartBar = na
var bool asianActive = false

// Asian session detection (for context)
bool inAsian = isInSession("1900-0000")

// Session boxes and lines
var box londonBox = na
var box nyBox = na
var box asianBox = na
var box powerHourBox = na

var line londonHighLine = na
var line londonLowLine = na
var line londonEqLine = na
var line nyHighLine = na
var line nyLowLine = na
var line nyEqLine = na
var line asianHighLine = na
var line asianLowLine = na

var label londonLbl = na
var label nyLbl = na
var label asianLbl = na

// Pivot line settings
bool showKZPivots = input.bool(true, "Show Session Pivots", group=kzGroup, tooltip="Extend session H/L as pivot lines")
bool showKZEQ = input.bool(true, "Show 50% Equilibrium", group=kzGroup, tooltip="Show equilibrium line at 50%")
int kzPivotExtend = input.int(50, "Pivot Extension Bars", minval=10, maxval=200, group=kzGroup)

color pivotHighColor = input.color(color.new(#00E676, 30), "Pivot High", group=kzGroup, inline="piv")
color pivotLowColor = input.color(color.new(#FF5252, 30), "Pivot Low", group=kzGroup, inline="piv")
color eqColor = input.color(color.new(#FFFFFF, 60), "EQ Color", group=kzGroup)

// â”€â”€â”€ LONDON SESSION â”€â”€â”€
if showKillzones and showOnChart
    // Session start
    if inLondon and not inLondon[1]
        londonActive := true
        londonStartBar := bar_index
        londonHigh := high
        londonLow := low
        // Delete old objects
        box.delete(londonBox)
        line.delete(londonHighLine)
        line.delete(londonLowLine)
        line.delete(londonEqLine)
        label.delete(londonLbl)
    
    // During session - track high/low
    if londonActive and inLondon
        londonHigh := math.max(londonHigh, high)
        londonLow := math.min(londonLow, low)
        
        // Update box
        box.delete(londonBox)
        londonBox := box.new(londonStartBar, londonHigh, bar_index, londonLow, border_color=color.new(londonColor, 20), border_width=1, bgcolor=londonColor, text="LONDON", text_color=color.white, text_size=size.tiny, text_halign=text.align_left, text_valign=text.align_top)
    
    // Session end - create pivot lines
    if not inLondon and inLondon[1] and londonActive
        londonActive := false
        float eqPrice = (londonHigh + londonLow) / 2
        
        // High pivot line
        if showKZPivots
            londonHighLine := line.new(bar_index, londonHigh, bar_index + kzPivotExtend, londonHigh, color=pivotHighColor, style=line.style_dotted, width=1)
            londonLowLine := line.new(bar_index, londonLow, bar_index + kzPivotExtend, londonLow, color=pivotLowColor, style=line.style_dotted, width=1)
        
        // 50% Equilibrium
        if showKZEQ
            londonEqLine := line.new(bar_index, eqPrice, bar_index + kzPivotExtend, eqPrice, color=eqColor, style=line.style_dashed, width=1)
        
        // Pivot labels
        londonLbl := label.new(bar_index + 2, londonHigh, "LDN H", style=label.style_none, textcolor=pivotHighColor, size=size.tiny)

// â”€â”€â”€ NEW YORK SESSION â”€â”€â”€
if showKillzones and showOnChart
    // Session start
    if inNY and not inNY[1]
        nyActive := true
        nyStartBar := bar_index
        nyHigh := high
        nyLow := low
        // Delete old objects
        box.delete(nyBox)
        line.delete(nyHighLine)
        line.delete(nyLowLine)
        line.delete(nyEqLine)
        label.delete(nyLbl)
    
    // During session - track high/low
    if nyActive and inNY
        nyHigh := math.max(nyHigh, high)
        nyLow := math.min(nyLow, low)
        
        // Update box
        box.delete(nyBox)
        nyBox := box.new(nyStartBar, nyHigh, bar_index, nyLow, border_color=color.new(nyColor, 20), border_width=1, bgcolor=nyColor, text="NY", text_color=color.white, text_size=size.tiny, text_halign=text.align_left, text_valign=text.align_top)
    
    // Session end - create pivot lines
    if not inNY and inNY[1] and nyActive
        nyActive := false
        float eqPrice = (nyHigh + nyLow) / 2
        
        // High/Low pivot lines
        if showKZPivots
            nyHighLine := line.new(bar_index, nyHigh, bar_index + kzPivotExtend, nyHigh, color=pivotHighColor, style=line.style_dotted, width=1)
            nyLowLine := line.new(bar_index, nyLow, bar_index + kzPivotExtend, nyLow, color=pivotLowColor, style=line.style_dotted, width=1)
        
        // 50% Equilibrium
        if showKZEQ
            nyEqLine := line.new(bar_index, eqPrice, bar_index + kzPivotExtend, eqPrice, color=eqColor, style=line.style_dashed, width=1)
        
        // Pivot labels
        nyLbl := label.new(bar_index + 2, nyHigh, "NY H", style=label.style_none, textcolor=pivotHighColor, size=size.tiny)

// â”€â”€â”€ ASIAN SESSION (for context) â”€â”€â”€
bool showAsian = input.bool(true, "Show Asian Range", group=kzGroup)
color asianColor = input.color(color.new(#9C27B0, 85), "Asian Color", group=kzGroup)

if showKillzones and showAsian and showOnChart
    if inAsian and not inAsian[1]
        asianActive := true
        asianStartBar := bar_index
        asianHigh := high
        asianLow := low
        box.delete(asianBox)
        line.delete(asianHighLine)
        line.delete(asianLowLine)
    
    if asianActive and inAsian
        asianHigh := math.max(asianHigh, high)
        asianLow := math.min(asianLow, low)
        
        box.delete(asianBox)
        asianBox := box.new(asianStartBar, asianHigh, bar_index, asianLow, border_color=color.new(asianColor, 20), border_width=1, bgcolor=asianColor, text="ASIAN", text_color=color.white, text_size=size.tiny, text_halign=text.align_left, text_valign=text.align_top)
    
    if not inAsian and inAsian[1] and asianActive
        asianActive := false
        if showKZPivots
            asianHighLine := line.new(bar_index, asianHigh, bar_index + kzPivotExtend, asianHigh, color=color.new(#CE93D8, 50), style=line.style_dotted, width=1)
            asianLowLine := line.new(bar_index, asianLow, bar_index + kzPivotExtend, asianLow, color=color.new(#CE93D8, 50), style=line.style_dotted, width=1)

// â”€â”€â”€ POWER HOUR HIGHLIGHT â”€â”€â”€
bgcolor(showPowerHour and inPowerHour and showOnChart ? powerHourColor : na, title="Power Hour")

if showPowerHour and inPowerHour and not inPowerHour[1] and showOnChart
    label.new(bar_index, high, "âš¡ POWER HOUR", style=label.style_label_down, color=powerHourColor, textcolor=color.white, size=size.small)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ SILVER BULLET TIME (10-11 AM EST) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool inSilverBullet = isInSession("1000-1100")
bgcolor(showSilverBullet and inSilverBullet and showOnChart ? silverBulletColor : na, title="Silver Bullet")

if showSilverBullet and inSilverBullet and not inSilverBullet[1] and showOnChart
    label.new(bar_index, high, "ğŸ¯ SILVER BULLET", style=label.style_label_down, color=color.new(#00FFFF, 50), textcolor=color.white, size=size.tiny)

// â”€â”€â”€ NO TRADE ZONE OVERLAY â”€â”€â”€
bool showNoTradeZone = input.bool(false, "Show No Trade Zone", group=kzGroup, tooltip="Highlight areas outside killzones (gray background)")
bool outsideKillzones = not inLondon and not inNY and not inAsian
bgcolor(showNoTradeZone and outsideKillzones and showOnChart ? color.new(#808080, 95) : na, title="No Trade Zone")
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ICT LEVELS - PDH/PDL & WEEKLY OPEN â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Previous Day High/Low
var float pdh = na
var float pdl = na
var line pdhLine = na
var line pdlLine = na
var label pdhLabel = na
var label pdlLabel = na

bool newDay = ta.change(time("D")) != 0

if newDay
    pdh := high[1]
    pdl := low[1]
    // Find actual previous day high/low (simplified)
    for i = 1 to 50
        if dayofweek[i] != dayofweek[i+1]
            break
        pdh := math.max(pdh, high[i])
        pdl := math.min(pdl, low[i])
    
    if showPDHL
        line.delete(pdhLine)
        line.delete(pdlLine)
        label.delete(pdhLabel)
        label.delete(pdlLabel)
        pdhLine := line.new(bar_index, pdh, last_bar_index + 20, pdh, color=pdhColor, style=line.style_dashed, width=1, extend=extendLevelLines ? extend.right : extend.none)
        pdlLine := line.new(bar_index, pdl, last_bar_index + 20, pdl, color=pdlColor, style=line.style_dashed, width=1, extend=extendLevelLines ? extend.right : extend.none)
        pdhLabel := label.new(last_bar_index + 5, pdh, "PDH", style=label.style_none, textcolor=pdhColor, size=size.tiny)
        pdlLabel := label.new(last_bar_index + 5, pdl, "PDL", style=label.style_none, textcolor=pdlColor, size=size.tiny)

// Weekly Open
var float weeklyOpen = na
var line woLine = na
var label woLabel = na

bool newWeek = ta.change(time("W")) != 0

if newWeek
    weeklyOpen := open
    if showWeeklyOpen
        line.delete(woLine)
        label.delete(woLabel)
        woLine := line.new(bar_index, weeklyOpen, last_bar_index + 20, weeklyOpen, color=weeklyOpenColor, style=line.style_solid, width=1, extend=extendLevelLines ? extend.right : extend.none)
        woLabel := label.new(last_bar_index + 5, weeklyOpen, "W.OPEN", style=label.style_none, textcolor=weeklyOpenColor, size=size.tiny)

// â”€â”€â”€ MIDNIGHT OPEN (00:00 EST) â”€â”€â”€
var float midnightOpen = na
var line midLine = na
var label midLabel = na

bool isMidnight = hour(time, tz) == 0 and minute(time) == 0
bool newMidnight = isMidnight and not isMidnight[1]

if newMidnight
    midnightOpen := open
    if showMidnightOpen
        line.delete(midLine)
        label.delete(midLabel)
        midLine := line.new(bar_index, midnightOpen, last_bar_index + 20, midnightOpen, color=midnightColor, style=line.style_solid, width=1, extend=extendLevelLines ? extend.right : extend.none)
        midLabel := label.new(last_bar_index + 5, midnightOpen, "00:00", style=label.style_none, textcolor=midnightColor, size=size.tiny)

// â”€â”€â”€ SESSION OPENS â”€â”€â”€
var float londonOpen = na
var float nyOpen = na
var line londonOpenLine = na
var line nyOpenLine = na
var label londonOpenLbl = na
var label nyOpenLbl = na

bool londonOpenTime = hour(time, tz) == 3 and minute(time) == 0
bool nyOpenTime = hour(time, tz) == 8 and minute(time) == 0

if showSessionOpens
    if londonOpenTime and not londonOpenTime[1]
        londonOpen := open
        line.delete(londonOpenLine)
        label.delete(londonOpenLbl)
        londonOpenLine := line.new(bar_index, londonOpen, last_bar_index + 20, londonOpen, color=londonOpenColor, style=line.style_dashed, width=1, extend=extendLevelLines ? extend.right : extend.none)
        londonOpenLbl := label.new(last_bar_index + 5, londonOpen, "LDN.O", style=label.style_none, textcolor=londonOpenColor, size=size.tiny)
    
    if nyOpenTime and not nyOpenTime[1]
        nyOpen := open
        line.delete(nyOpenLine)
        label.delete(nyOpenLbl)
        nyOpenLine := line.new(bar_index, nyOpen, last_bar_index + 20, nyOpen, color=nyOpenColor, style=line.style_dashed, width=1, extend=extendLevelLines ? extend.right : extend.none)
        nyOpenLbl := label.new(last_bar_index + 5, nyOpen, "NY.O", style=label.style_none, textcolor=nyOpenColor, size=size.tiny)

// â”€â”€â”€ NY SESSION HIGH/LOW (separate from KZ pivots) â”€â”€â”€
var float nySessHigh = na
var float nySessLow = na
var line nySessHighLine = na
var line nySessLowLine = na
var label nySessHighLbl = na
var label nySessLowLbl = na

if showSessionOpens and inNY
    // Reset at NY open
    if nyOpenTime and not nyOpenTime[1]
        nySessHigh := high
        nySessLow := low
    else
        nySessHigh := math.max(nz(nySessHigh, high), high)
        nySessLow := math.min(nz(nySessLow, low), low)
    
    // Update lines
    line.delete(nySessHighLine)
    line.delete(nySessLowLine)
    label.delete(nySessHighLbl)
    label.delete(nySessLowLbl)
    nySessHighLine := line.new(bar_index - 50, nySessHigh, last_bar_index + 20, nySessHigh, color=color.new(#FF6B6B, 50), style=line.style_dotted, width=1, extend=extendLevelLines ? extend.right : extend.none)
    nySessLowLine := line.new(bar_index - 50, nySessLow, last_bar_index + 20, nySessLow, color=color.new(#4ECDC4, 50), style=line.style_dotted, width=1, extend=extendLevelLines ? extend.right : extend.none)
    nySessHighLbl := label.new(last_bar_index + 5, nySessHigh, "NY.H", style=label.style_none, textcolor=color.new(#FF6B6B, 30), size=size.tiny)
    nySessLowLbl := label.new(last_bar_index + 5, nySessLow, "NY.L", style=label.style_none, textcolor=color.new(#4ECDC4, 30), size=size.tiny)
// â”€â”€â”€ ATR CALCULATION â”€â”€â”€
float atrValue = ta.atr(atrLength)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ FRACTAL-FRIENDLY HTF LEVEL DETECTION â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Helper function to convert timeframe to readable label
htfLabel(string tf) =>
    switch tf
        "1" => "1m"
        "5" => "5m"
        "15" => "15m"
        "30" => "30m"
        "60" => "1H"
        "120" => "2H"
        "240" => "4H"
        "D" => "D"
        "1D" => "D"
        "W" => "W"
        "1W" => "W"
        "M" => "M"
        "1M" => "M"
        => tf

// HTF data via request.security()
htfHigh = request.security(syminfo.tickerid, htfTimeframe, high)
htfLow = request.security(syminfo.tickerid, htfTimeframe, low)
htfClose = request.security(syminfo.tickerid, htfTimeframe, close)
htfOpen = request.security(syminfo.tickerid, htfTimeframe, open)
htfHigh2 = request.security(syminfo.tickerid, htfTimeframe, high[2])
htfLow2 = request.security(syminfo.tickerid, htfTimeframe, low[2])

// Detect new HTF bar to prevent duplicate drawings
htfTime = request.security(syminfo.tickerid, htfTimeframe, time)
bool newHTFBar = ta.change(htfTime) != 0

// HTF swing detection for OBs
htfPivotHigh = request.security(syminfo.tickerid, htfTimeframe, ta.pivothigh(high, 3, 3))
htfPivotLow = request.security(syminfo.tickerid, htfTimeframe, ta.pivotlow(low, 3, 3))

// HTF FVG detection (gap between candle 1 and candle 3)
bool htfBullFVG = htfLow > htfHigh2 and (htfLow - htfHigh2) > atrValue * 0.2
bool htfBearFVG = htfHigh < htfLow2 and (htfLow2 - htfHigh) > atrValue * 0.2

// HTF OB tracking arrays
var box[] htfBullOBs = array.new_box()
var box[] htfBearOBs = array.new_box()
var box[] htfBullFVGs = array.new_box()
var box[] htfBearFVGs = array.new_box()

// Track HTF levels for fractal filter
var float[] htfLevelPrices = array.new_float()

// HTF OB detection - bullish (bearish candle before bullish impulse on HTF)
htfBullishImpulse = htfClose > htfOpen and (htfClose - htfOpen) > atrValue * 1.5
htfBearishCandlePrev = request.security(syminfo.tickerid, htfTimeframe, close[1] < open[1])
htfBearishCandleBefore = htfBearishCandlePrev and htfBullishImpulse

// HTF OB detection - bearish (bullish candle before bearish impulse on HTF)
htfBearishImpulse = htfClose < htfOpen and (htfOpen - htfClose) > atrValue * 1.5
htfBullishCandlePrev = request.security(syminfo.tickerid, htfTimeframe, close[1] > open[1])
htfBullishCandleBefore = htfBullishCandlePrev and htfBearishImpulse

// Pre-fetch HTF OB high/low (must be at global scope)
htfOBHighPrev = request.security(syminfo.tickerid, htfTimeframe, high[1])
htfOBLowPrev = request.security(syminfo.tickerid, htfTimeframe, low[1])

// Draw HTF Bullish OB (using pre-fetched data)
if showHTFLevels and showHTFOrderBlocks and htfBearishCandleBefore and newHTFBar and showOnChart
    htfOBBox = box.new(bar_index - 5, htfOBHighPrev, bar_index + 50, htfOBLowPrev, border_color=htfOBBullColor, border_width=1, border_style=line.style_dashed, bgcolor=htfOBBullColor, text=htfLabel(htfTimeframe) + " OB", text_color=color.white, text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_top)
    array.push(htfBullOBs, htfOBBox)
    array.push(htfLevelPrices, (htfOBHighPrev + htfOBLowPrev) / 2)
    if array.size(htfBullOBs) > maxHTFOB
        box.delete(array.shift(htfBullOBs))
    if array.size(htfLevelPrices) > maxHTFOB * 2 + maxHTFFVG * 2
        array.shift(htfLevelPrices)

// Draw HTF Bearish OB (using pre-fetched data)
if showHTFLevels and showHTFOrderBlocks and htfBullishCandleBefore and newHTFBar and showOnChart
    htfOBBox = box.new(bar_index - 5, htfOBHighPrev, bar_index + 50, htfOBLowPrev, border_color=htfOBBearColor, border_width=1, border_style=line.style_dashed, bgcolor=htfOBBearColor, text=htfLabel(htfTimeframe) + " OB", text_color=color.white, text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_top)
    array.push(htfBearOBs, htfOBBox)
    array.push(htfLevelPrices, (htfOBHighPrev + htfOBLowPrev) / 2)
    if array.size(htfBearOBs) > maxHTFOB
        box.delete(array.shift(htfBearOBs))
    if array.size(htfLevelPrices) > maxHTFOB * 2 + maxHTFFVG * 2
        array.shift(htfLevelPrices)

// Draw HTF Bull FVG
if showHTFLevels and showHTFFVG and htfBullFVG and newHTFBar and showOnChart
    htfFVGBox = box.new(bar_index - 3, htfLow, bar_index + 40, htfHigh2, border_color=htfFVGBullColor, border_width=1, border_style=line.style_dotted, bgcolor=htfFVGBullColor, text=htfLabel(htfTimeframe) + " FVG", text_color=color.white, text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_center)
    array.push(htfBullFVGs, htfFVGBox)
    array.push(htfLevelPrices, (htfLow + htfHigh2) / 2)
    if array.size(htfBullFVGs) > maxHTFFVG
        box.delete(array.shift(htfBullFVGs))

// Draw HTF Bear FVG
if showHTFLevels and showHTFFVG and htfBearFVG and newHTFBar and showOnChart
    htfFVGBox = box.new(bar_index - 3, htfLow2, bar_index + 40, htfHigh, border_color=htfFVGBearColor, border_width=1, border_style=line.style_dotted, bgcolor=htfFVGBearColor, text=htfLabel(htfTimeframe) + " FVG", text_color=color.white, text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_center)
    array.push(htfBearFVGs, htfFVGBox)
    array.push(htfLevelPrices, (htfLow2 + htfHigh) / 2)
    if array.size(htfBearFVGs) > maxHTFFVG
        box.delete(array.shift(htfBearFVGs))

// â”€â”€â”€ FRACTAL FILTER: Check if price is near any HTF level â”€â”€â”€
isNearHTFLevel() =>
    bool nearLevel = false
    float proximityDist = atrValue * fractalATRMult
    if array.size(htfLevelPrices) > 0
        for i = 0 to array.size(htfLevelPrices) - 1
            float lvl = array.get(htfLevelPrices, i)
            if math.abs(close - lvl) <= proximityDist
                nearLevel := true
                break
    nearLevel

bool nearHTF = isNearHTFLevel()
bool fractalOK = fractalFilter ? nearHTF : true  // Pass if filter off or near HTF

// â”€â”€â”€ LIQUIDITY SWEEP DETECTION â”€â”€â”€
// Track recent swing highs/lows for liquidity (local pivot detection)
float liqPivotHigh = ta.pivothigh(high, pivotLen, pivotLen)
float liqPivotLow = ta.pivotlow(low, pivotLen, pivotLen)

var float recentSwingHigh = na
var float recentSwingLow = na

// Update swing levels
if not na(liqPivotHigh)
    recentSwingHigh := high[pivotLen]
if not na(liqPivotLow)
    recentSwingLow := low[pivotLen]

// Detect sweeps (price takes out level then reverses)
bool bullishSweep = not na(recentSwingLow) and low < recentSwingLow and close > recentSwingLow
bool bearishSweep = not na(recentSwingHigh) and high > recentSwingHigh and close < recentSwingHigh

if showLiqSweeps and bullishSweep and barstate.isconfirmed and showOnChart
    label.new(bar_index, low, "ğŸ’§", style=label.style_label_up, color=color.new(#00E676, 50), textcolor=color.white, size=size.tiny, tooltip="Liquidity Sweep - Bullish")
    recentSwingLow := na

if showLiqSweeps and bearishSweep and barstate.isconfirmed and showOnChart
    label.new(bar_index, high, "ğŸ’§", style=label.style_label_down, color=color.new(#FF5252, 50), textcolor=color.white, size=size.tiny, tooltip="Liquidity Sweep - Bearish")
    recentSwingHigh := na

// â”€â”€â”€ TURTLE SOUP DETECTION (ICT False Breakout) â”€â”€â”€
// Classic 20-bar high/low sweep + reversal pattern
// Visual context only - NOT a trading signal

// Key levels: lookback period high/low (exclude current bar)
float tsKeyHigh = ta.highest(high, tsLookback)[1]
float tsKeyLow = ta.lowest(low, tsLookback)[1]

// TS Long: Sweep below key low + close back above (bullish reversal)
bool tsSweepLowWick = low < tsKeyLow
bool tsCloseAboveLow = close > tsKeyLow
bool tsLongPattern = tsSweepLowWick and tsCloseAboveLow

// TS Short: Sweep above key high + close back below (bearish reversal)  
bool tsSweepHighWick = high > tsKeyHigh
bool tsCloseBelowHigh = close < tsKeyHigh
bool tsShortPattern = tsSweepHighWick and tsCloseBelowHigh

// Session filter (optional)
bool tsSessionOK = tsSessionFilter ? (inLondon or inNY) : true

// Plot TS patterns (visual detection only)
if showTS and tsLongPattern and tsSessionOK and barstate.isconfirmed and showOnChart
    label.new(bar_index, low, "ğŸ¢", style=label.style_label_up, color=tsBullColor, textcolor=color.white, size=size.small, tooltip="Turtle Soup Long\nFalse breakdown - swept " + str.tostring(tsLookback) + "-bar low")

if showTS and tsShortPattern and tsSessionOK and barstate.isconfirmed and showOnChart
    label.new(bar_index, high, "ğŸ¢", style=label.style_label_down, color=tsBearColor, textcolor=color.white, size=size.small, tooltip="Turtle Soup Short\nFalse breakout - swept " + str.tostring(tsLookback) + "-bar high")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ SUSPENSION BLOCKS (ICT 2025 - Volume Imbalance Zones) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Suspension Block = A candlestick with:
// 1. Volume Imbalance ABOVE (gap between SB body top and left candle's low wick)
// 2. Volume Imbalance BELOW (gap between SB body bottom and right candle's high wick)
// 3. Left candle's wick MUST overlap SB body (no FVG can form)
// Acts as support/resistance (PD Array) for entries

var box[] suspensionBlocks = array.new_box()

// We check candle at [1] as the potential Suspension Block (confirmed on close)
// Left candle = [2], Right candle = [0]

if showSB and bar_index > 3 and barstate.isconfirmed and showOnChart
    // Minimum gap size filter
    float sbMinGap = atrValue * sbMinGapATR
    
    // SB Candle values (the middle candle we're checking)
    float sbOpen = open[1]
    float sbClose = close[1]
    float sbHigh = high[1]
    float sbLow = low[1]
    float sbBodyTop = math.max(sbOpen, sbClose)
    float sbBodyBottom = math.min(sbOpen, sbClose)
    
    // Left candle (candle before SB)
    float leftHigh = high[2]
    float leftLow = low[2]
    float leftOpen = open[2]
    float leftClose = close[2]
    float leftBodyTop = math.max(leftOpen, leftClose)
    float leftBodyBottom = math.min(leftOpen, leftClose)
    
    // Right candle (candle after SB = current candle)
    float rightHigh = high[0]
    float rightLow = low[0]
    float rightOpen = open[0]
    float rightClose = close[0]
    float rightBodyTop = math.max(rightOpen, rightClose)
    float rightBodyBottom = math.min(rightOpen, rightClose)
    
    // Volume Imbalance ABOVE SB:
    // Gap between SB candle body TOP and LEFT candle's LOW (wick tip)
    // For bullish context: left candle's low must be BELOW SB body top with a gap
    bool viAbove = sbBodyTop < leftLow - sbMinGap
    
    // Volume Imbalance BELOW SB:
    // Gap between SB candle body BOTTOM and RIGHT candle's HIGH (wick tip)
    // For bearish context: right candle's high must be ABOVE SB body bottom with a gap
    bool viBelow = sbBodyBottom > rightHigh + sbMinGap
    
    // KEY REQUIREMENT: Left candle's WICK must overlap SB body
    // This prevents FVG formation - the wick reaches into where SB body is
    bool leftWickOverlapsSB = leftLow < sbBodyTop and leftLow > sbBodyBottom
    
    // Alternative: Also check if left candle's body or wick extends through SB body range
    bool leftCandleOverlapsSB = leftLow <= sbBodyTop or leftHigh >= sbBodyBottom
    
    // Determine if bullish or bearish SB
    bool isBullishSB = sbClose > sbOpen
    
    // Suspension Block detected
    bool sbDetected = viAbove and viBelow and leftWickOverlapsSB
    
    if sbDetected
        // Draw the SB zone using the SB candle's body range
        sbBox = box.new(bar_index - 1, sbBodyTop, bar_index + 30, sbBodyBottom, border_color=sbColor, border_width=2, bgcolor=sbColor, text="SB", text_color=color.new(#FFB400, 0), text_size=size.tiny, text_halign=text.align_left, text_valign=text.align_center)
        array.push(suspensionBlocks, sbBox)
        if array.size(suspensionBlocks) > maxSBCount
            box.delete(array.shift(suspensionBlocks))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ FAIR VALUE GAPS (FVG + iFVG) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// FVG Detection
var box[] bullFVGs = array.new_box()
var box[] bearFVGs = array.new_box()


if showFVG and bar_index > 2 and showOnChart
    // Minimum gap size filter (10% of ATR to avoid tiny insignificant gaps)
    float minGapSize = atrValue * 0.1
    
    // Bullish FVG: Gap up (candle 1 high < candle 3 low)
    bool bullFVGDetected = low > high[2]
    float bullGapSize = low - high[2]
    if bullFVGDetected and bullGapSize >= minGapSize
        fvgTop = low
        fvgBottom = high[2]
        fvgBox = box.new(bar_index - 1, fvgTop, bar_index + 20, fvgBottom, border_color=bullFVGColor, border_style=line.style_dotted, bgcolor=bullFVGColor, text="FVG", text_color=color.new(#00E676, 20), text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bullFVGs, fvgBox)
        if array.size(bullFVGs) > maxFVGCount
            box.delete(array.shift(bullFVGs))
    
    // Bearish FVG: Gap down (candle 1 low > candle 3 high)
    bool bearFVGDetected = high < low[2]
    float bearGapSize = low[2] - high
    if bearFVGDetected and bearGapSize >= minGapSize
        fvgTop = low[2]
        fvgBottom = high
        fvgBox = box.new(bar_index - 1, fvgTop, bar_index + 20, fvgBottom, border_color=bearFVGColor, border_style=line.style_dotted, bgcolor=bearFVGColor, text="FVG", text_color=color.new(#FF5252, 20), text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bearFVGs, fvgBox)
        if array.size(bearFVGs) > maxFVGCount
            box.delete(array.shift(bearFVGs))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ 1ST PRESENTED FVG (ICT 2025 - Opening Range Reference) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// The FIRST FVG formed after 9:30 AM NY within the Opening Range (until 10:00 AM)
// Acts as a key daily reference level - extend until 3:45 PM NY

var box firstPresentedFVGBox = na
var bool foundFirstFVGToday = false
var int lastFirstFVGDay = -1

// Reset tracking at start of new day
if dayofweek != dayofweek[1]
    foundFirstFVGToday := false
    if not na(firstPresentedFVGBox)
        box.delete(firstPresentedFVGBox)
        firstPresentedFVGBox := na
    lastFirstFVGDay := dayofweek

// NY time check (Opening Range: 9:30 AM - 10:00 AM NY = 14:30 - 15:00 UTC)
// Using session to check if we're in opening range window
float nyHour = hour(time, "America/New_York")
float nyMinute = minute(time, "America/New_York")
float nyTimeDecimal = nyHour + nyMinute / 60.0

// Opening Range: 9:30 AM to 10:00 AM NY (9.5 to 10.0 in decimal)
bool isOpeningRange = nyTimeDecimal >= 9.5 and nyTimeDecimal < 10.0

// Extend zone end time until 3:45 PM NY (adjust box right edge)
bool shouldExtend = nyTimeDecimal >= 9.5 and nyTimeDecimal < 15.75

if show1stFVG and bar_index > 2 and not foundFirstFVGToday and isOpeningRange and showOnChart
    float minGapSize1st = atrValue * 0.1
    
    // Bullish FVG check: low > high[2] (gap up)
    bool bullFVG1st = low > high[2]
    float bullGap1st = low - high[2]
    
    // Bearish FVG check: high < low[2] (gap down)
    bool bearFVG1st = high < low[2]
    float bearGap1st = low[2] - high
    
    // VALIDATION: FVG candle [1] must break range of candles before it
    // For bullish: candle [1] high > previous candles high
    // For bearish: candle [1] low < previous candles low
    bool bullBreaksRange = high[1] > math.max(high[2], high[3])
    bool bearBreaksRange = low[1] < math.min(low[2], low[3])
    
    // Detect first valid FVG
    if bullFVG1st and bullGap1st >= minGapSize1st and bullBreaksRange
        foundFirstFVGToday := true
        float fvgTop1st = low
        float fvgBottom1st = high[2]
        firstPresentedFVGBox := box.new(bar_index - 1, fvgTop1st, bar_index + 200, fvgBottom1st, border_color=firstFVGColor, border_width=2, border_style=line.style_solid, bgcolor=firstFVGColor, text="1st FVG", text_color=color.new(#FFD700, 0), text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)
    
    if bearFVG1st and bearGap1st >= minGapSize1st and bearBreaksRange and not foundFirstFVGToday
        foundFirstFVGToday := true
        float fvgTop1st = low[2]
        float fvgBottom1st = high
        firstPresentedFVGBox := box.new(bar_index - 1, fvgTop1st, bar_index + 200, fvgBottom1st, border_color=firstFVGColor, border_width=2, border_style=line.style_solid, bgcolor=firstFVGColor, text="1st FVG", text_color=color.new(#FFD700, 0), text_size=size.small, text_halign=text.align_right, text_valign=text.align_center)

// Keep extending the box right edge as long as we're in the trading day
if not na(firstPresentedFVGBox) and shouldExtend
    box.set_right(firstPresentedFVGBox, bar_index + 1)

// iFVG Detection and Mitigation Cleanup
// iFVG = when price ENTERS and FILLS 50%+ of the gap (true mitigation)
// Track which FVGs have been mitigated
var bool[] bullFVGMitigated = array.new_bool()
var bool[] bearFVGMitigated = array.new_bool()

// Sync mitigation arrays with FVG arrays when FVGs are created
if showFVG and bar_index > 2 and showOnChart
    // When a new bull FVG is created, add false to mitigation array
    float bullGapCheck = low - high[2]
    if low > high[2] and bullGapCheck >= atrValue * 0.1
        array.push(bullFVGMitigated, false)
        if array.size(bullFVGMitigated) > maxFVGCount
            array.shift(bullFVGMitigated)
    // When a new bear FVG is created, add false to mitigation array
    float bearGapCheck = low[2] - high
    if high < low[2] and bearGapCheck >= atrValue * 0.1
        array.push(bearFVGMitigated, false)
        if array.size(bearFVGMitigated) > maxFVGCount
            array.shift(bearFVGMitigated)

if showIFVG or deleteFVGOnMitigation
    // Check bull FVGs (gap below price - iFVG when close sweeps DOWN through it)
    if array.size(bullFVGs) > 0
        for i = array.size(bullFVGs) - 1 to 0
            if i < array.size(bullFVGs) and i < array.size(bullFVGMitigated)
                fvgBox = array.get(bullFVGs, i)
                fvgTop = box.get_top(fvgBox)
                fvgBottom = box.get_bottom(fvgBox)
                
                // iFVG = CLOSE fully sweeps through the gap (body closes below bottom)
                // This means the gap is "mitigated" and becomes a continuation zone
                bool closedThroughGap = close < fvgBottom
                bool alreadyMitigated = array.get(bullFVGMitigated, i)
                
                if closedThroughGap
                    if deleteFVGOnMitigation
                        box.delete(fvgBox)
                        array.remove(bullFVGs, i)
                        array.remove(bullFVGMitigated, i)
                    else if showIFVG and not alreadyMitigated
                        // Mark as iFVG - now a continuation zone
                        box.set_bgcolor(fvgBox, ifvgColor)
                        box.set_border_color(fvgBox, ifvgColor)
                        box.set_text(fvgBox, "iFVG")
                        box.set_text_color(fvgBox, color.new(#FFD700, 20))
                        array.set(bullFVGMitigated, i, true)
    
    // Check bear FVGs (gap above price - iFVG when close sweeps UP through it)
    if array.size(bearFVGs) > 0
        for i = array.size(bearFVGs) - 1 to 0
            if i < array.size(bearFVGs) and i < array.size(bearFVGMitigated)
                fvgBox = array.get(bearFVGs, i)
                fvgTop = box.get_top(fvgBox)
                fvgBottom = box.get_bottom(fvgBox)
                
                // iFVG = CLOSE fully sweeps through the gap (body closes above top)
                bool closedThroughGap = close > fvgTop
                bool alreadyMitigated = array.get(bearFVGMitigated, i)
                
                if closedThroughGap
                    if deleteFVGOnMitigation
                        box.delete(fvgBox)
                        array.remove(bearFVGs, i)
                        array.remove(bearFVGMitigated, i)
                    else if showIFVG and not alreadyMitigated
                        // Mark as iFVG - now a continuation zone
                        box.set_bgcolor(fvgBox, ifvgColor)
                        box.set_border_color(fvgBox, ifvgColor)
                        box.set_text(fvgBox, "iFVG")
                        box.set_text_color(fvgBox, color.new(#FFD700, 20))
                        array.set(bearFVGMitigated, i, true)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ VOLUME IMBALANCE (VI) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Volume Imbalance = 2-candle gap where wicks don't overlap
var box[] bullVIs = array.new_box()
var box[] bearVIs = array.new_box()

if showVI and bar_index > 1 and showOnChart
    // Minimum gap size filter (10% of ATR)
    float minVISize = atrValue * 0.1
    
    // Bullish VI: Current candle's low > previous candle's high (gap up, wicks don't touch)
    bool bullVIDetected = low > high[1]
    float bullVISize = low - high[1]
    if bullVIDetected and bullVISize >= minVISize
        viTop = low
        viBottom = high[1]
        viBox = box.new(bar_index - 1, viTop, bar_index + 15, viBottom, border_color=bullVIColor, border_style=line.style_solid, bgcolor=bullVIColor, text="VI", text_color=color.new(#00BCD4, 20), text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bullVIs, viBox)
        if array.size(bullVIs) > maxVICount
            box.delete(array.shift(bullVIs))
    
    // Bearish VI: Current candle's high < previous candle's low (gap down, wicks don't touch)
    bool bearVIDetected = high < low[1]
    float bearVISize = low[1] - high
    if bearVIDetected and bearVISize >= minVISize
        viTop = low[1]
        viBottom = high
        viBox = box.new(bar_index - 1, viTop, bar_index + 15, viBottom, border_color=bearVIColor, border_style=line.style_solid, bgcolor=bearVIColor, text="VI", text_color=color.new(#E91E63, 20), text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_center)
        array.push(bearVIs, viBox)
        if array.size(bearVIs) > maxVICount
            box.delete(array.shift(bearVIs))

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ BOLLINGER BANDS PLOTTING â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
plot(showBB ? bbUpper : na, "BB Upper", bbColor, 1)
plot(showBB ? bbBasis : na, "BB Mid", color.new(bbColor, 70), 1, plot.style_circles)
plot(showBB ? bbLower : na, "BB Lower", bbColor, 1)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ EMA RIBBON PLOTTING â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
p1 = plot(showEMAs ? ema8 : na, "EMA Fast", color.new(#00E676, 0), 2)
p2 = plot(showEMAs ? ema21 : na, "EMA Slow", color.new(#FFA726, 0), 2)
p3 = plot(showEMAs and gameMode == "SWING" ? ema200 : na, "EMA Trend", color.new(#AB47BC, 0), 2, plot.style_line)
p4 = plot(showEMAs ? ema5 : na, "EMA Trail", color.new(#FFD700, 50), 1, plot.style_line)

// EMA Ribbon fill
ribbonColor = bullTrend ? emaBullColor : emaBearColor
fill(p1, p2, showEMARibbon ? ribbonColor : na, title="EMA Ribbon")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ THE GHOST TAPE (VOLUME & FLOW) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. Relative Volume (RVOL)
float rvol = volume / ta.sma(volume, 20)

// 2. Volume Delta (Simulated Tape)
// Estimate buying/selling pressure within the candle
float candleRange = high - low
float bodyRange = math.abs(close - open)
float wickRatio = candleRange == 0 ? 0 : bodyRange / candleRange
bool isAbsorption = rvol > 1.5 and wickRatio < 0.5 // High Vol, Small Body

// 3. Money Flow Index (Smart Money Pressure)
float mfiVal = ta.mfi(close, 14)
bool flowBull = mfiVal > 50
bool flowBear = mfiVal < 50

// 4. Flow Dashboard Text
string flow_txt = isAbsorption ? "âš ï¸ ABSORPTION" : flowBull ? "ğŸŒŠ BULLISH FLOW" : "ğŸŒŠ BEARISH FLOW"
color flow_col = isAbsorption ? color.white : flowBull ? color.lime : color.red

// 5. Institutional Candle Colors
color tapeColor = na

if showCandleColors
    if buySignal
        tapeColor := signalBuyColor // Signal Override
    else if sellSignal
        tapeColor := signalSellColor // Signal Override
    else if isAbsorption
        tapeColor := color.white // ABSORPTION (Reversal Warning)
    else if rvol > 1.5
        // High Volume (Institutional Push)
        tapeColor := close > open ? #00E676 : #FF5252 
    else
        // Low Volume (Retail Drift)
        tapeColor := close > open ? color.new(#006400, 30) : color.new(#8B0000, 30) 
else
    tapeColor := na

barcolor(tapeColor, title="Ghost Tape Colors")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ SIGNAL ARROWS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Killzone filter for signals (optional)
bool kzAllowed = killzoneSignalsOnly ? (inLondon or inNY) : true

// Fractal-filtered signals (only when fractalFilter is enabled AND price near HTF level)
bool fractalBuyOK = buySignal and fractalOK
bool fractalSellOK = sellSignal and fractalOK

// Best Setup Detection - All 3 confluences + Power Hour + Volume + Fractal alignment
bool buyBBTouch = low <= bbLower
bool sellBBTouch = high >= bbUpper
bool inActiveKZ = inLondon or inNY or inPowerHour
bool highVol = rvol > 1.5

bool bestBuySetup = fractalBuyOK and buyBBTouch and inActiveKZ and highVol
bool bestSellSetup = fractalSellOK and sellBBTouch and inActiveKZ and highVol

// Best Setup uses larger size and brighter color
color bestBuyColor = color.new(#00FF00, 0)  // Bright green
color bestSellColor = color.new(#FF0000, 0)  // Bright red

// Normal signals (small) - with fractal filter
plotshape(showSignals and fractalBuyOK and not bestBuySetup and showOnChart and kzAllowed ? low : na, "Buy Signal", shape.triangleup, location.belowbar, signalBuyColor, size=size.small)
plotshape(showSignals and fractalSellOK and not bestSellSetup and showOnChart and kzAllowed ? high : na, "Sell Signal", shape.triangledown, location.abovebar, signalSellColor, size=size.small)

// BEST SETUP signals (larger)
plotshape(showSignals and bestBuySetup and showOnChart and kzAllowed ? low : na, "â­ BEST BUY Setup", shape.triangleup, location.belowbar, bestBuyColor, size=size.normal)
plotshape(showSignals and bestSellSetup and showOnChart and kzAllowed ? high : na, "â­ BEST SELL Setup", shape.triangledown, location.abovebar, bestSellColor, size=size.normal)

// Signal labels with price - using fractal-filtered signals
if showSignals and fractalBuyOK and showOnChart and kzAllowed
    label.new(bar_index, low, "BUY\n" + str.tostring(close, format.mintick), style=label.style_label_up, color=signalBuyColor, textcolor=color.white, size=size.tiny)
    // BB Touch label
    if low <= bbLower
        label.new(bar_index, low - atrValue * 0.2, "BB TOUCH", style=label.style_none, textcolor=color.new(#64B5F6, 30), size=size.tiny)
    // HTF Proximity label (when fractal filter active)
    if fractalFilter and nearHTF
        label.new(bar_index, low - atrValue * 0.35, "ğŸ“Š HTF", style=label.style_none, textcolor=color.new(#00FFFF, 20), size=size.tiny)

if showSignals and fractalSellOK and showOnChart and kzAllowed
    label.new(bar_index, high, "SELL\n" + str.tostring(close, format.mintick), style=label.style_label_down, color=signalSellColor, textcolor=color.white, size=size.tiny)
    // BB Touch label
    if high >= bbUpper
        label.new(bar_index, high + atrValue * 0.2, "BB TOUCH", style=label.style_none, textcolor=color.new(#64B5F6, 30), size=size.tiny)
    // HTF Proximity label (when fractal filter active)
    if fractalFilter and nearHTF
        label.new(bar_index, high + atrValue * 0.35, "ğŸ“Š HTF", style=label.style_none, textcolor=color.new(#00FFFF, 20), size=size.tiny)

// Best Setup Labels (special highlight)
if showSignals and bestBuySetup and showOnChart and kzAllowed
    label.new(bar_index, low - atrValue * 0.4, "â­ BEST SETUP", style=label.style_none, textcolor=color.new(#FFD700, 0), size=size.small)

if showSignals and bestSellSetup and showOnChart and kzAllowed
    label.new(bar_index, high + atrValue * 0.4, "â­ BEST SETUP", style=label.style_none, textcolor=color.new(#FFD700, 0), size=size.small)

// â”€â”€â”€ ATR-BASED SL/TP LEVELS â”€â”€â”€
var line slLine = na
var line tpLine = na
var label slLabel = na
var label tpLabel = na
var float activeSL = na
var float activeTP = na
var bool isLongTrade = na
var int signalBar = na

if showATRLevels and (buySignal or sellSignal) and showOnChart
    line.delete(slLine)
    line.delete(tpLine)
    label.delete(slLabel)
    label.delete(tpLabel)
    
    float slDist = atrValue * atrMultSL
    float tpDist = atrValue * atrMultTP
    signalBar := bar_index
    
    if buySignal
        float slPrice = close - slDist
        float tpPrice = close + tpDist
        activeSL := slPrice
        activeTP := tpPrice
        isLongTrade := true
        slLine := line.new(bar_index, slPrice, bar_index + 50, slPrice, color=slColor, style=line.style_dashed, width=1)
        tpLine := line.new(bar_index, tpPrice, bar_index + 50, tpPrice, color=tpColor, style=line.style_dashed, width=1)
        slLabel := label.new(bar_index + 25, slPrice, "SL: " + str.tostring(slPrice, format.mintick), style=label.style_none, textcolor=slColor, size=size.tiny)
        tpLabel := label.new(bar_index + 25, tpPrice, "TP: " + str.tostring(tpPrice, format.mintick), style=label.style_none, textcolor=tpColor, size=size.tiny)
    
    if sellSignal
        float slPrice = close + slDist
        float tpPrice = close - tpDist
        activeSL := slPrice
        activeTP := tpPrice
        isLongTrade := false
        slLine := line.new(bar_index, slPrice, bar_index + 50, slPrice, color=slColor, style=line.style_dashed, width=1)
        tpLine := line.new(bar_index, tpPrice, bar_index + 50, tpPrice, color=tpColor, style=line.style_dashed, width=1)
        slLabel := label.new(bar_index + 25, slPrice, "SL: " + str.tostring(slPrice, format.mintick), style=label.style_none, textcolor=slColor, size=size.tiny)
        tpLabel := label.new(bar_index + 25, tpPrice, "TP: " + str.tostring(tpPrice, format.mintick), style=label.style_none, textcolor=tpColor, size=size.tiny)

// SL/TP Auto-cleanup - remove when target hit or after 50 bars
if not na(activeSL)
    bool slHit = isLongTrade ? low <= activeSL : high >= activeSL
    bool tpHit = isLongTrade ? high >= activeTP : low <= activeTP
    bool expired = bar_index > signalBar + 50
    
    if slHit or tpHit or expired
        line.delete(slLine)
        line.delete(tpLine)
        label.delete(slLabel)
        label.delete(tpLabel)
        activeSL := na
        activeTP := na

// â”€â”€â”€ 5-EMA TRAILING STOP LINE â”€â”€â”€
// Trail with 5-period EMA once +1 R in profit (institutional trailing rule)
plot(showATRLevels ? ema5 : na, "5-EMA Trail (+1R)", color.new(#FFEA00, 20), 3, plot.style_line)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ SMC - TRUE ICT HIERARCHICAL SWING DETECTION â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// ICT Definition:
// STH/STL = Basic 3-candle fractal (swing high/low)
// ITH/ITL = STH/STL with lower STHs/higher STLs on BOTH sides
// LTH/LTL = ITH/ITL with lower ITHs/higher ITLs on BOTH sides

// â”€â”€â”€ SWING TRACKING ARRAYS â”€â”€â”€
var float[] swingHighPrices = array.new_float(0)
var int[] swingHighBars = array.new_int(0)
var float[] swingLowPrices = array.new_float(0)
var int[] swingLowBars = array.new_int(0)
int maxSwings = 20

// â”€â”€â”€ BASIC SWING DETECTION (3-candle fractal) â”€â”€â”€
int basePivot = 3
float pivotHighVal = ta.pivothigh(high, basePivot, basePivot)
float pivotLowVal = ta.pivotlow(low, basePivot, basePivot)
bool newSwingHigh = not na(pivotHighVal)
bool newSwingLow = not na(pivotLowVal)

// â”€â”€â”€ ADD NEW SWINGS TO ARRAYS â”€â”€â”€
if newSwingHigh
    array.push(swingHighPrices, high[basePivot])
    array.push(swingHighBars, bar_index - basePivot)
    if array.size(swingHighPrices) > maxSwings
        array.shift(swingHighPrices)
        array.shift(swingHighBars)

if newSwingLow
    array.push(swingLowPrices, low[basePivot])
    array.push(swingLowBars, bar_index - basePivot)
    if array.size(swingLowPrices) > maxSwings
        array.shift(swingLowPrices)
        array.shift(swingLowBars)

// â”€â”€â”€ DETERMINE SWING TYPE (TRUE ICT HIERARCHICAL) â”€â”€â”€
// LTH = Absolute highest swing in tracked history
// ITH = Higher than immediate neighbors (local peak)
// STH = Basic swing (all others)

getHighType() =>
    string result = "STH"
    int sz = array.size(swingHighPrices)
    if sz >= 2
        float curr = array.get(swingHighPrices, sz - 1)  // Latest swing
        
        // Find the absolute highest in the array
        float maxPrice = curr
        for i = 0 to sz - 1
            float p = array.get(swingHighPrices, i)
            if p > maxPrice
                maxPrice := p
        
        // Check if current is the absolute highest (LTH)
        if curr >= maxPrice
            result := "LTH"
        else if sz >= 3
            // Check if ITH (higher than immediate neighbors)
            float left = array.get(swingHighPrices, sz - 2)
            if curr > left
                result := "ITH"
    result

getLowType() =>
    string result = "STL"
    int sz = array.size(swingLowPrices)
    if sz >= 2
        float curr = array.get(swingLowPrices, sz - 1)
        
        // Find the absolute lowest in the array
        float minPrice = curr
        for i = 0 to sz - 1
            float p = array.get(swingLowPrices, i)
            if p < minPrice
                minPrice := p
        
        // Check if current is the absolute lowest (LTL)
        if curr <= minPrice
            result := "LTL"
        else if sz >= 3
            // Check if ITL (lower than immediate neighbor)
            float left = array.get(swingLowPrices, sz - 2)
            if curr < left
                result := "ITL"
    result

// â”€â”€â”€ DRAW SWING LABELS â”€â”€â”€
if showSwings and newSwingHigh and showOnChart
    string highType = getHighType()
    color lblColor = highType == "LTH" ? color.new(#FF1744, 20) : highType == "ITH" ? color.new(#FF5722, 40) : color.new(bearOBColor, 50)
    label.new(bar_index - basePivot, high[basePivot], highType, style=label.style_label_down, color=lblColor, textcolor=color.white, size=size.tiny)

if showSwings and newSwingLow and showOnChart
    string lowType = getLowType()
    color lblColor = lowType == "LTL" ? color.new(#00E676, 20) : lowType == "ITL" ? color.new(#4CAF50, 40) : color.new(bullOBColor, 50)
    label.new(bar_index - basePivot, low[basePivot], lowType, style=label.style_label_up, color=lblColor, textcolor=color.white, size=size.tiny)

// Order Block logic
var box[] bullOBBoxes = array.new_box()
var box[] bearOBBoxes = array.new_box()

// Helper function to check if OB overlaps with existing ones
checkOBOverlap(box[] obArray, float obHigh, float obLow) =>
    bool overlaps = false
    if array.size(obArray) > 0
        for j = 0 to array.size(obArray) - 1
            existingBox = array.get(obArray, j)
            existingTop = box.get_top(existingBox)
            existingBottom = box.get_bottom(existingBox)
            // Check if price ranges overlap
            if not (obLow > existingTop or obHigh < existingBottom)
                overlaps := true
                break
    overlaps

// Find consecutive bearish candles before swing low (Bullish OB)
// ICT Quality Filter: Requires 2+ down-close candles (building sell pressure = exhaustion zone)
float minOBSize = atrValue * 0.3

// Helper: count consecutive bearish candles starting at index
countConsecutiveBearish(int startIdx) =>
    int count = 0
    for k = startIdx to startIdx + 5
        if close[k] < open[k]
            count += 1
        else
            break
    count

// Helper: count consecutive bullish candles starting at index  
countConsecutiveBullish(int startIdx) =>
    int count = 0
    for k = startIdx to startIdx + 5
        if close[k] > open[k]
            count += 1
        else
            break
    count

if showOB and newSwingLow
    for i = pivotLen to pivotLen + 10
        if close[i] < open[i]
            float obHigh = math.max(open[i], close[i])  // Use body high (not wick) per ICT
            float obLow = math.min(open[i], close[i])   // Use body low (not wick) per ICT
            float obSize = high[i] - low[i]
            bool hasOverlap = checkOBOverlap(bullOBBoxes, obHigh, obLow)
            bool isSigificant = obSize >= minOBSize
            int consecCount = countConsecutiveBearish(i)
            bool hasConsecutive = consecCount >= obMinConsecutive
            if not hasOverlap and isSigificant and hasConsecutive
                string obLabel = consecCount >= 3 ? "PRIME" : "FRESH"
                obBox = box.new(bar_index - i, obHigh, bar_index + 20, obLow, border_color=bullOBColor, border_style=line.style_dotted, bgcolor=color.new(bullOBColor, 92), text=obLabel, text_color=color.new(#26A69A, 30), text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_top)
                array.push(bullOBBoxes, obBox)
                if array.size(bullOBBoxes) > maxOBCount
                    box.delete(array.shift(bullOBBoxes))
            break

// Find consecutive bullish candles before swing high (Bearish OB)
if showOB and newSwingHigh
    for i = pivotLen to pivotLen + 10
        if close[i] > open[i]
            float obHigh = math.max(open[i], close[i])  // Use body high per ICT
            float obLow = math.min(open[i], close[i])   // Use body low per ICT
            float obSize = high[i] - low[i]
            bool hasOverlap = checkOBOverlap(bearOBBoxes, obHigh, obLow)
            bool isSigificant = obSize >= minOBSize
            int consecCount = countConsecutiveBullish(i)
            bool hasConsecutive = consecCount >= obMinConsecutive
            if not hasOverlap and isSigificant and hasConsecutive
                string obLabel = consecCount >= 3 ? "PRIME" : "FRESH"
                obBox = box.new(bar_index - i, obHigh, bar_index + 20, obLow, border_color=bearOBColor, border_style=line.style_dotted, bgcolor=color.new(bearOBColor, 92), text=obLabel, text_color=color.new(#EF5350, 30), text_size=size.tiny, text_halign=text.align_right, text_valign=text.align_bottom)
                array.push(bearOBBoxes, obBox)
                if array.size(bearOBBoxes) > maxOBCount
                    box.delete(array.shift(bearOBBoxes))
            break

// OB Mitigation Cleanup - delete OBs when price passes through them
if deleteOBOnMitigation
    // Check bull OBs - delete if price closes below the OB
    if array.size(bullOBBoxes) > 0
        for i = array.size(bullOBBoxes) - 1 to 0
            if i < array.size(bullOBBoxes)
                obBox = array.get(bullOBBoxes, i)
                obBottom = box.get_bottom(obBox)
                if close < obBottom
                    box.delete(obBox)
                    array.remove(bullOBBoxes, i)
    
    // Check bear OBs - delete if price closes above the OB
    if array.size(bearOBBoxes) > 0
        for i = array.size(bearOBBoxes) - 1 to 0
            if i < array.size(bearOBBoxes)
                obBox = array.get(bearOBBoxes, i)
                obTop = box.get_top(obBox)
                if close > obTop
                    box.delete(obBox)
                    array.remove(bearOBBoxes, i)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ MTF TREND DATA â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Request higher timeframe EMAs (needed for QPE)
float ema8_m15 = request.security(syminfo.tickerid, "15", ta.ema(close, 8))
float ema21_m15 = request.security(syminfo.tickerid, "15", ta.ema(close, 21))
float ema8_h1 = request.security(syminfo.tickerid, "60", ta.ema(close, 8))
float ema21_h1 = request.security(syminfo.tickerid, "60", ta.ema(close, 21))
float ema8_h4 = request.security(syminfo.tickerid, "240", ta.ema(close, 8))
float ema21_h4 = request.security(syminfo.tickerid, "240", ta.ema(close, 21))

// HTF Bias EMAs (EMA50 vs EMA200 on 1H chart)
float ema50_h1 = request.security(syminfo.tickerid, "60", ta.ema(close, 50))
float ema200_h1 = request.security(syminfo.tickerid, "60", ta.ema(close, 200))

bool m15Bull = ema8_m15 > ema21_m15
bool h1Bull = ema8_h1 > ema21_h1
bool h4Bull = ema8_h4 > ema21_h4

// HTF Bias: Green = bullish, Red = bearish, Grey = neutral (intertwined)
bool htfBullish = ema50_h1 > ema200_h1
bool htfBearish = ema50_h1 < ema200_h1
bool htfNeutral = math.abs(ema50_h1 - ema200_h1) < atrValue * 0.5  // Within 0.5 ATR = neutral

// Background color based on HTF bias
color htfBgColor = htfNeutral ? color.new(#808080, 95) : htfBullish ? color.new(#00E676, 95) : color.new(#FF5252, 95)
bgcolor(showHTFBackground ? htfBgColor : na, title="HTF Trend Background")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ QUANTUM PROBABILITY ENGINE (QPE) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// 1. Volume Factor (Is volume pumping?)
bool vol_surge = volume > ta.sma(volume, 20) * 1.5

// 2. Momentum Factor (Is RSI supporting the move?)
float rsi_val = ta.rsi(close, 14)
bool mom_ok_buy = rsi_val > 40 and rsi_val < 70
bool mom_ok_sell = rsi_val < 60 and rsi_val > 30

// 3. Volatility Factor (Is there room to move?)
float bb_width = bbUpper - bbLower
bool vol_ok = bb_width > ta.sma(bb_width, 20)

// 4. Trend Factor (HTF Alignment - H1) - Already calculated: h1Bull

// â”€â”€â”€ SCORING ALGORITHM â”€â”€â”€
// Calculate fresh each bar (not persistent)
int score = 0
bool hasActiveSignal = buySignal or sellSignal

if hasActiveSignal
    if (buySignal and h1Bull) or (sellSignal and not h1Bull)
        score += 30  // Trend Alignment
    if vol_surge
        score += 20  // Volume Surge
    if (buySignal and mom_ok_buy) or (sellSignal and mom_ok_sell)
        score += 20  // Momentum
    if vol_ok
        score += 15  // Volatility
    if inPowerHour or inSilverBullet
        score += 15  // Time Boost

// Probability display strings
string prob_txt = score >= 80 ? "ğŸ”® QUANTUM LOCK (" + str.tostring(score) + "%)" : score >= 60 ? "âš¡ HIGH PROB (" + str.tostring(score) + "%)" : score > 0 ? "âš ï¸ WEAK (" + str.tostring(score) + "%)" : "---"
color prob_col = score >= 80 ? color.new(#00E676, 0) : score >= 60 ? color.new(#FFD700, 0) : score > 0 ? color.new(#FF5252, 0) : color.gray

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ DASHBOARD (HEADS-UP DISPLAY) â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
if showDashboard
    var table dashboard = table.new(position.bottom_right, 2, 10, bgcolor=color.new(#000000, 50), border_width=1, border_color=color.new(#FFFFFF, 80))
    
    // Header - Retail Beast FX Branding (matching logo)
    table.cell(dashboard, 0, 0, "ğŸ¦", text_color=color.new(#00FF00, 0), text_size=size.small, text_halign=text.align_center)
    table.cell(dashboard, 1, 0, "RETAIL BEAST FX v8.4", text_color=color.new(#00FF00, 0), text_size=size.small, text_halign=text.align_left)
    
    // Mode & Preset
    table.cell(dashboard, 0, 1, "MODE", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    modeColor = gameMode == "SCALPER" ? color.lime : gameMode == "DAY TRADER" ? color.orange : color.aqua
    string modeDisplay = preset == "ğŸ”¥ Beast Mode" ? gameMode + " ğŸ”¥" : gameMode
    table.cell(dashboard, 1, 1, modeDisplay, text_color=modeColor, text_size=size.tiny, text_halign=text.align_left)
    
    // Alpha Edge Strategy (NEW)
    table.cell(dashboard, 0, 2, "ALPHA EDGE", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    color alphaColor = alphaStrategy != "Off" ? color.new(#00FFFF, 0) : color.gray
    table.cell(dashboard, 1, 2, alphaStrategy, text_color=alphaColor, text_size=size.tiny, text_halign=text.align_left)
    
    // Session Status (with Silver Bullet)
    table.cell(dashboard, 0, 3, "SESSION", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    string sessionText = inSilverBullet ? "ğŸ¯ SILVER BULLET" : inPowerHour ? "âš¡ POWER HOUR" : inLondon ? "LONDON OPEN" : inNY ? "NY OPEN" : validSession ? "ACTIVE" : "NO TRADE ZONE"
    color sessionColor = inSilverBullet ? color.new(#00FFFF, 0) : inPowerHour ? color.new(#1E90FF, 0) : inLondon ? color.teal : inNY ? color.orange : validSession ? color.lime : color.gray
    table.cell(dashboard, 1, 3, sessionText, text_color=sessionColor, text_size=size.tiny, text_halign=text.align_left)
    
    // Signal Status
    table.cell(dashboard, 0, 4, "SIGNAL", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    string signalText = buySignal ? "ğŸŸ¢ BUY DETECTED" : sellSignal ? "ğŸ”´ SELL DETECTED" : validSession ? "SCANNING..." : "WAITING..."
    color signalColor = buySignal ? signalBuyColor : sellSignal ? signalSellColor : color.gray
    table.cell(dashboard, 1, 4, signalText, text_color=signalColor, text_size=size.tiny, text_halign=text.align_left)
    
    // Trend
    table.cell(dashboard, 0, 5, "TREND", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    string trendText = bullTrend ? "BULLISH â–²" : bearTrend ? "BEARISH â–¼" : "NEUTRAL"
    color trendColor = bullTrend ? color.lime : bearTrend ? color.red : color.gray
    table.cell(dashboard, 1, 5, trendText, text_color=trendColor, text_size=size.tiny, text_halign=text.align_left)
    
    // PDH/PDL Status
    table.cell(dashboard, 0, 6, "LEVELS", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    string levelText = close > pdh ? "ABOVE PDH" : close < pdl ? "BELOW PDL" : "IN RANGE"
    color levelColor = close > pdh ? color.lime : close < pdl ? color.red : color.gray
    table.cell(dashboard, 1, 6, levelText, text_color=levelColor, text_size=size.tiny, text_halign=text.align_left)
    
    // ATR Info
    table.cell(dashboard, 0, 7, "ATR", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    table.cell(dashboard, 1, 7, str.tostring(atrValue, format.mintick), text_color=color.white, text_size=size.tiny, text_halign=text.align_left)
    
    // ORACLE - Quantum Probability Engine
    table.cell(dashboard, 0, 8, "ORACLE", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    table.cell(dashboard, 1, 8, prob_txt, text_color=prob_col, text_size=size.tiny, text_halign=text.align_left)
    
    // THE TAPE - Money Flow (Ghost Tape)
    table.cell(dashboard, 0, 9, "THE TAPE", text_color=color.gray, text_size=size.tiny, text_halign=text.align_right)
    table.cell(dashboard, 1, 9, flow_txt, text_color=flow_col, text_size=size.tiny, text_halign=text.align_left)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ MTF TREND TABLE â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
bool showMTF = input.bool(true, "Show MTF Table", group=visGroup)

if showMTF
    var table mtfTable = table.new(position.top_right, 2, 4, bgcolor=color.new(#000000, 50), border_width=1, border_color=color.new(#FFFFFF, 80))
    
    table.cell(mtfTable, 0, 0, "MTF", text_color=color.new(#00BFFF, 0), text_size=size.tiny, text_halign=text.align_center)
    table.cell(mtfTable, 1, 0, "TREND", text_color=color.white, text_size=size.tiny, text_halign=text.align_center)
    
    // Current TF
    table.cell(mtfTable, 0, 1, timeframe.period, text_color=color.gray, text_size=size.tiny, text_halign=text.align_center)
    table.cell(mtfTable, 1, 1, bullTrend ? "â–²" : "â–¼", text_color=bullTrend ? color.lime : color.red, text_size=size.tiny, text_halign=text.align_center)
    
    // M15
    table.cell(mtfTable, 0, 2, "15m", text_color=color.gray, text_size=size.tiny, text_halign=text.align_center)
    table.cell(mtfTable, 1, 2, m15Bull ? "â–²" : "â–¼", text_color=m15Bull ? color.lime : color.red, text_size=size.tiny, text_halign=text.align_center)
    
    // H1
    table.cell(mtfTable, 0, 3, "1H", text_color=color.gray, text_size=size.tiny, text_halign=text.align_center)
    table.cell(mtfTable, 1, 3, h1Bull ? "â–²" : "â–¼", text_color=h1Bull ? color.lime : color.red, text_size=size.tiny, text_halign=text.align_center)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ WATERMARK â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
var table watermark = table.new(position.bottom_left, 1, 1, bgcolor=color.new(#000000, 95))
table.cell(watermark, 0, 0, "RetailBeastFX v8.1 | 2025", text_color=color.new(#FFFFFF, 70), text_size=size.tiny)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ ALERTS â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
alertcondition(buySignal or sellSignal, title="RetailBeast Signal", message="{{plot_0}}")

// Plot for alert message (hidden)
plot(buySignal or sellSignal ? close : na, "Alert Price", display=display.none)

// All alert conditions
alertcondition(buySignal, title="Buy Signal", message="ğŸŸ¢ RetailBeast BUY @ {{close}} on {{ticker}}")
alertcondition(sellSignal, title="Sell Signal", message="ğŸ”´ RetailBeast SELL @ {{close}} on {{ticker}}")
alertcondition(inPowerHour and not inPowerHour[1], title="Power Hour Start", message="âš¡ POWER HOUR started on {{ticker}}")
alertcondition(inSilverBullet and not inSilverBullet[1], title="Silver Bullet Start", message="ğŸ¯ SILVER BULLET time started on {{ticker}}")
alertcondition(bullishSweep, title="Bullish Liquidity Sweep", message="ğŸ’§ Bullish liquidity sweep on {{ticker}}")
alertcondition(bearishSweep, title="Bearish Liquidity Sweep", message="ğŸ’§ Bearish liquidity sweep on {{ticker}}")
alertcondition(close > pdh, title="Above PDH", message="ğŸ“ˆ Price above Previous Day High on {{ticker}}")
alertcondition(close < pdl, title="Below PDL", message="ğŸ“‰ Price below Previous Day Low on {{ticker}}")

// Swap/Rollover Alert (16:55 ET daily for carry trade prep)
bool swapAlertTime = hour(time, tz) == 16 and minute(time) == 55
alertcondition(swapAlertTime and not swapAlertTime[1], title="Swap Time Alert", message="â° SWAP TIME - Check rollover rates for carry trade on {{ticker}}")

// HTF Bias Change Alert
alertcondition(htfBullish and not htfBullish[1], title="HTF Bullish", message="ğŸŸ¢ HTF turned BULLISH (1H EMA50 > EMA200) on {{ticker}}")
alertcondition(htfBearish and not htfBearish[1], title="HTF Bearish", message="ğŸ”´ HTF turned BEARISH (1H EMA50 < EMA200) on {{ticker}}")

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// â–ˆâ–ˆâ–ˆ END OF SCRIPT â–ˆâ–ˆâ–ˆ
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
